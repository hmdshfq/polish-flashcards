rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ===== HELPER FUNCTION =====
    // Check if current user is an admin
    function isAdmin() {
      return request.auth != null
             && exists(/databases/$(database)/documents/user_roles/$(request.auth.uid))
             && get(/databases/$(database)/documents/user_roles/$(request.auth.uid)).data.role == 'admin';
    }

    // ===== ADMIN ROLES =====
    // Admins are identified by entries in this collection
    // Only admins can create/read their own role document
    match /user_roles/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if false; // Managed via admin SDK or backend only
    }

    // ===== PUBLIC READ-ONLY VOCABULARY DATA =====
    // All users can read vocabulary data (levels, categories, flashcards)
    // Only admins can write

    match /levels/{levelId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    match /categories/{categoryId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    match /flashcards/{flashcardId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // ===== USER PROGRESS - ISOLATED PER USER =====
    // Each user can only read and write their own progress data
    // This uses subcollections for automatic user isolation via path rules

    match /user_progress/{userId} {
      // Users can only access their own progress container
      allow read, write: if request.auth != null && request.auth.uid == userId;

      match /cards/{flashcardId} {
        // Inherit parent rule - user can read/write their own cards
        allow read, write: if request.auth != null && request.auth.uid == userId;

        // Validate schema on writes to ensure data integrity
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              // Required fields must exist
                              && request.resource.data.keys().hasAll([
                                'ease_factor',
                                'review_count',
                                'last_reviewed_at',
                                'next_review_at'
                              ])
                              // Validate field types
                              && request.resource.data.ease_factor is number
                              && request.resource.data.review_count is int
                              && request.resource.data.last_reviewed_at is timestamp
                              && request.resource.data.next_review_at is timestamp
                              // Validate ease_factor bounds (SM-2 algorithm constraint)
                              && request.resource.data.ease_factor >= 1.3
                              // Validate review_count is non-negative
                              && request.resource.data.review_count >= 0;

        // Allow deletion of progress entries
        allow delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // ===== DENY ALL OTHER ACCESS =====
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
